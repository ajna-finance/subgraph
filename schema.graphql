# TODO: track approvals?
# TODO: finish expanding this schema -> ERC20 / ERC721?
# TODO: track token liquidity across all Ajna pools
# this supports both ERC20 and ERC721 tokens, as union types aren't currently supported
type Token @entity {
  # token address
  id: Bytes!
  # token symbol
  symbol: String!
  # token name
  name: String!
  # token decimals
  decimals: BigInt!
  # flag for whether the token is an ERC721
  # TODO: make this a string, enabling new pool types (such as ERC1155)
  isERC721: Boolean!
  # number of pools including this token
  poolCount: BigInt!
  # total supply of the token
  totalSupply: BigInt!
  # transactions across all pools that include this token
  txCount: BigInt!
}

type ERC20PoolFactory @entity {
  # factory address
  id: Bytes!
  # number of pools deployed by the factory
  poolCount: BigInt!
  # list of pools deployed by the factory
  pools: [Pool!]!
  # total number of transactions sent to the factory
  txCount: BigInt!
}

type Pool @entity {
  # pool address
  id: Bytes!
  # block pool was created at
  createdAtBlockNumber: BigInt!
  # creation timestamp
  createdAtTimestamp: BigInt!
  # address of the pool's collateral token
  collateralToken: Token!
  # address of the pool's quote token
  quoteToken: Token!
  # fee rate of the pool
  feeRate: BigDecimal!
  # current total debt in the pool
  currentDebt: BigDecimal!
  # current pool inflator snapshot
  inflator: BigDecimal!
  # block timestamp at which the inflator was last updated
  inflatorUpdate: BigInt!
  # current pool interest rate
  interestRate: BigDecimal!
  # total collateral pledged to the pool
  pledgedCollateral: BigDecimal!
  # total interest earned by all lenders in the pool
  totalInterestEarned: BigDecimal!
  # total number of transactions sent to the pool
  txCount: BigInt!

  # LOANS INFORMATION
  poolSize: BigDecimal! # total amount of quote tokens in the pool
  loansCount: BigInt! # total number of loans in the pool
  maxBorrower: Bytes! # address of the borrower with the highest TP in the pool
  pendingInflator: BigDecimal! # pending inflator value
  pendingInterestFactor: BigDecimal! # pending interest factor used to scale the inflator

  # PRICES INFORMATION
  hpb: BigDecimal! # current highest price bucket
  hpbIndex: Int! # current highest price bucket index
  htp: BigDecimal! # current highest threshold price
  htpIndex: Int! # current highest threshold price index
  lup: BigDecimal! # current lowest utilized price
  lupIndex: Int! # current lowest utilized price index  
  momp: BigDecimal! # most optimistic matching price

  # RESERVES INFORMATION
  # current reserves contractQuoteBalance + poolDebt - pool.depositSize()
  reserves: BigDecimal!
  # current pool claimable reserves
  claimableReserves: BigDecimal!
  # remaining claimable reserves not yet taken
  claimableReservesRemaining: BigDecimal!
  # current reserve auction auctionPrice
  reserveAuctionPrice: BigDecimal!
  # current reserve auction timeRemaining
  reserveAuctionTimeRemaining: BigInt!
  # current burn epoch
  burnEpoch: BigInt!
  # total ajna burned in the pool
  totalAjnaBurned: BigDecimal!
  # list of all reserve auctions for this pool
  reserveAuctions: [ReserveAuction!]! 

  # UTILIZATION INFORMATION
  # current pool minimum debt amount for a new borrow
  minDebtAmount: BigDecimal!
  # current pool collateralization ratio across all borrowers
  collateralization: BigDecimal!
  # current pool utilization across all borrowers
  actualUtilization: BigDecimal!
  # current pool target utilization rate
  targetUtilization: BigDecimal!

  # LIQUIDATION INFORMATION
  # liquidation bond currently escrowed in the pool
  totalBondEscrowed: BigDecimal!
  # list of active liquidation auctions in the pool, sorted by kick time
  liquidationAuctions: [LiquidationAuction!]!
}

type Bucket @entity {
  # bucket id: $poolAddress + '#' + $bucketIndex
  id: Bytes!
  # bucket index
  bucketIndex: Int!
  # current exchange rate of the bucket
  exchangeRate: BigDecimal!
  # pool address
  poolAddress: String!
  # total collateral available in the bucket
  collateral: BigDecimal!
  # total quote tokens deposited in the bucket, inclusive of interest
  deposit: BigDecimal!
  # total LP for all lenders in the bucket
  lpb: BigDecimal!
}

# lend occurs per bucket in a pool
type Lend @entity {
  # Lend id: $bucketId + '|' + $accountId
  id: Bytes!
  # bucket to which a lend was made
  bucket: Bucket!
  # pool address
  poolAddress: String!
  # address of the lender
  lender: Bytes!
  # pool pointer
  pool: Pool!
  # amount of LPB lender has in the bucket
  lpb: BigDecimal!
  # quote equivalent value of the lend's LPB in the bucket (regardless of available deposit in bucket)
  lpbValueInQuote: BigDecimal!
  # depositTime: BigInt! # timestamp of last lend interaction
}

# each borrower has only one loan with a pool
type Loan @entity {
  # Loan id: $poolAddress + '|' + $borrowerId
  id: Bytes!
  # pool address
  poolAddress: String!
  # borrower address
  borrower: Bytes!
  # pool pointer
  pool: Pool!
  # boolean indicating whether the loan is in liquidations
  inLiquidation: Boolean!
  # collateral tokens deposited in a pool by the borrower
  collateralPledged: BigDecimal!
  # collateralization of the borrow position in the pool
  collateralization: BigDecimal!
  # total quote drawn from the pool in the loan
  debt: BigDecimal!
  # borrowers threshold price
  tp: BigDecimal!
}

type Account @entity {
  # address of the account
  id: Bytes!
  # list of pools in which an account is present
  pools: [Pool!]!

  # kicks executed by the account
  kicks: [Kick!]!
  # buckets in a pool to which the account has lent quote
  lends: [Lend!]!
  # loans which the account has taken from pools
  loans: [Loan!]!
  settles: [Settle!]!
  takes: [Take!]!

  # reserve auctions which the account has interacted in
  reserveAuctions: [ReserveAuction!]!

  # total number of transactions sent by the account
  txCount: BigInt!
}

type LiquidationAuction @entity {
  id: Bytes!                       # $poolAddress + '|' + $loanId + '|' + blockNumber
  pool: Pool!                      # pool in which the liquidation occurred
  borrower: Bytes!                 # address of the borrower being liquidated
  auctionPrice: BigDecimal!        # initial price at which auction was kicked # FIXME: not exposed
  collateral: BigDecimal!          # initial collateral up for auction
  collateralRemaining: BigDecimal! # collateral which has not been taken
  debt: BigDecimal!                # initial debt to be covered by the auction
  debtRemaining: BigDecimal!       # debt which has not been covered
  loan: Loan!                      # loan being liquidated
  kicker: Bytes!                   # address of the kicker
  kick: Kick!                      # kick which triggered the liquidation
  kickTime: BigInt!                # block timestamp at which the kick was executed
  takes: [Take!]!                  # list of takes which occured using outside liquidity
  bucketTakes: [BucketTake!]!      # list of takes which involved the pool's book
  settle: AuctionSettle            # used to reconcile the liquidation
  settleTime: BigInt               # block timestamp at which the liquidation was settled
  settled: Boolean!                # boolean indicating whether the auction has been settled
  bondSize: BigDecimal!            # bond provided by kicker to initate auction
  bondFactor: BigDecimal!          # bond factor determining the reward or penalty for the kicker
  neutralPrice: BigDecimal!        # price at which kicker will have their bond returned without penalty or reward
}

# tracks the reserve auction process across multiple takes in a single auction
# used as start and take events are emitted as ReserveAuction
type ReserveAuction @entity {
  id: Bytes! # $poolAddress + '|' + $burnEpoch
  kicker: Bytes! # address of the kicker
  kickerAward: BigDecimal! # amount of quote rewarded to kicker for starting reserves auction
  kickTime: BigInt! # block timestamp at which the reserve auction started
  pool: Pool! # Pool in which the reserve auction occurred
  claimableReservesRemaining: BigDecimal! # uint256 claimable reserves remaining at start or at latest take
  auctionPrice: BigDecimal! # uint256 price at start or at latest take
  burnEpoch: BigInt! # uint256 burn epoch at which the reserve auction was started
  reserveAuctionTakes: [ReserveAuctionKickOrTake!]! # list of reserve auction takes that occured during this auction process
  ajnaBurnedAcrossAllTakes: BigDecimal! # total amount of ajna burned across all takes in the reserve auction
}

# updated upon ApproveLpTransferors and RevokeLpTransferors
type LPTransferors @entity {
  id: Bytes! # $poolAddress + '|' + $lender
  pool: Pool! # pool in which these transferors have been approved
  lender: Bytes! # address of the lender who has approved transferors
  transferors: [Bytes!]! # addresses of approved transferors
}

# represents a LP allowance for a single bucket
type LPAllowance @entity {
  id: Bytes!          # LPAllowances.id + '|' + $index
  index: Int!         # bucket index where an allowance has been granted
  amount: BigDecimal! # size of the allowance (measured in LP)
}

# updated upon SetLpAllowance and RevokeLpAllowance
type LPAllowances @entity {
  id: Bytes! # $poolAddress + '|' + $lender + '|' + $spender
  pool: Pool! # pool in which LP allowances have been granted
  lender: Bytes! # address of the lender who has granted an allowance
  spender: Bytes! # address who has been granted an allowance
  allowances: [LPAllowance!]! # list of LP allowances
}

  # # # # # #
  # EVENTS  #
  # # # # # #

type AddCollateral @entity(immutable: true) {
  id: Bytes!
  pool: Pool!            # Pool to which collateral was added
  bucket: Bucket!        # Bucket to which collateral was added
  actor: Bytes!          # address
  index: Int!            # uint256
  amount: BigDecimal!    # uint256
  lpAwarded: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type AddQuoteToken @entity(immutable: true) {
  id: Bytes!
  pool: Pool!            # Pool to which quote was added
  bucket: Bucket!        # Bucket to which quote was added
  lender: Bytes!         # address
  index: Int!            # uint256
  amount: BigDecimal!    # uint256
  lpAwarded: BigDecimal! # uint256
  lup: BigDecimal!       # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type AuctionNFTSettle @entity(immutable: true) {
  id: Bytes!
  borrower: Bytes!        # address
  collateral: BigDecimal! # uint256
  lps: BigDecimal!        # uint256
  index: Int!             # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# emitted when auction has been removed from the liquidation queue
type AuctionSettle @entity(immutable: true) {
  id: Bytes!
  pool: Pool!             # Pool whose debt was settled
  loan: Loan!             # Loan which was settled
  borrower: Bytes!        # address
  collateral: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type BondWithdrawn @entity(immutable: true) {
  id: Bytes!
  kicker: Bytes!      # address
  reciever: Bytes!    # address
  amount: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type BucketBankruptcy @entity(immutable: true) {
  id: Bytes!
  bucket: Bucket!          # Bucket which was bankrupted
  index: Int!              # uint256
  pool: Pool!              # Pool whose bucket was bankrupted
  lpForfeited: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type BucketTake @entity(immutable: true) {
  id: Bytes!
  taker: Bytes!           # address of the taker
  liquidationAuction: LiquidationAuction! # liquidation auction in which the take is occuring
  loan: Loan!             # loan which was taken
  pool: Pool!             # pool in which the take is occuring
  borrower: Bytes!        # address
  index: Int!             # uint256
  amount: BigDecimal!     # uint256
  collateral: BigDecimal! # uint256
  bondChange: BigDecimal! # uint256
  isReward: Boolean!      # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type BucketTakeLPAwarded @entity(immutable: true) {
  id: Bytes!
  taker: Bytes!                # address
  pool: Pool!                  # Pool in which the take occurred
  kicker: Bytes!               # address
  lpAwardedTaker: BigDecimal!  # uint256
  lpAwardedKicker: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DrawDebt @entity(immutable: true) {
  id: Bytes!
  pool: Pool!                    # Pool debt was drawn from
  borrower: Bytes!               # address
  amountBorrowed: BigDecimal!    # uint256
  collateralPledged: BigDecimal! # uint256
  lup: BigDecimal!               # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Kick @entity {
  id: Bytes!
  kicker: Bytes!          # address of the kicker
  kickMomp: BigDecimal!   # pool MOMP at the time of kicking
  pool: Pool!             # Pool in which a kick occurred
  loan: Loan!             # Loan which was kicked
  locked: BigDecimal!     # amount of quote from the bond locked in the kick (updated on take)
  claimable: BigDecimal!  # amount of quote from the bond claimable by the kicker (updated on settle)
  liquidationAuction: LiquidationAuction! # Liquidation auction which was initiated
  borrower: Bytes!        # address of the borrower being liquidated
  debt: BigDecimal!       # uint256
  collateral: BigDecimal! # uint256
  bond: BigDecimal!       # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type LoanStamped @entity(immutable: true) {
  id: Bytes!
  pool: Pool!
  borrower: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MoveQuoteToken @entity(immutable: true) {
  id: Bytes!
  pool: Pool!                 # Pool in which quote tokens were moved
  lender: Bytes!              # address
  from: Bucket!               # bucket quote token was moved from
  to: Bucket!                 # bucket quote token was moved to
  amount: BigDecimal!         # uint256
  lpRedeemedFrom: BigDecimal! # uint256
  lpAwardedTo: BigDecimal!    # uint256
  lup: BigDecimal!            # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RemoveCollateral @entity(immutable: true) {
  id: Bytes!
  pool: Pool!             # Pool where collateral was removed
  bucket: Bucket!         # Bucket where collateral was removed
  claimer: Bytes!         # address
  index: Int!             # uint256
  amount: BigDecimal!     # uint256
  lpRedeemed: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RemoveQuoteToken @entity(immutable: true) {
  id: Bytes!
  pool: Pool!             # Pool where deposit was removed
  bucket: Bucket!         # Bucket where deposit was removed
  lender: Bytes!          # address
  index: Int!             # uint256
  amount: BigDecimal!     # uint256
  lpRedeemed: BigDecimal! # uint256
  lup: BigDecimal!        # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RepayDebt @entity(immutable: true) {
  id: Bytes!
  pool: Pool!                   # Pool debt was repaid to
  borrower: Bytes!              # address
  quoteRepaid: BigDecimal!      # uint256
  collateralPulled: BigDecimal! # uint256
  lup: BigDecimal!              # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# a reserve auction take or start event
type ReserveAuctionKickOrTake @entity(immutable: true) {
  id: Bytes!                         # transaction.hash + transaction.from
  taker: Bytes                       # address of the taker, null if emitted as start of event
  reserveAuction: ReserveAuction!    # reserve auction in which the take is occuring
  pool: Pool!                        # pool in which the take is occuring
  claimableReservesRemaining: BigDecimal! # uint256 remaining amount of claimable reserves in the auction
  auctionPrice: BigDecimal!          # uint256 auction price at time of event emit
  incrementalAjnaBurned: BigDecimal! # amount of ajna burned in this take
  currentBurnEpoch: BigInt!          # current burn epoch
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# emitted for each settle TX; one to many required before auction is settled
type Settle @entity(immutable: true) {
  id: Bytes!
  pool: Pool!              # Pool whose debt was settled
  liquidationAuction: LiquidationAuction! # Liquidation auction which was settled
  loan: Loan!              # Loan which was settled
  borrower: Bytes!         # address
  settledDebt: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Take @entity(immutable: true) {
  id: Bytes!
  taker: Bytes!           # address of the taker
  pool: Pool!             # Pool in which the take occurred
  borrower: Bytes!        # address of the borrower being liquidated
  liquidationAuction: LiquidationAuction! # Liquidation auction which was taken
  loan: Loan!             # Loan which was taken
  amount: BigDecimal!     # uint256
  collateral: BigDecimal! # uint256
  bondChange: BigDecimal! # uint256
  isReward: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TransferLPs @entity(immutable: true) {
  id: Bytes!
  owner: Bytes!    # address
  newOwner: Bytes! # address
  indexes: [Int!]! # uint256[]
  lps: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UpdateInterestRate @entity(immutable: true) {
  id: Bytes!
  pool: Pool!          # Pool whose interest rate was updated
  oldRate: BigDecimal! # uint256
  newRate: BigDecimal! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
type Approval @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  approved: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ApprovalForAll @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  operator: Bytes! # address
  approved: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MoveLiquidity @entity(immutable: true) {
  id: Bytes!
  lender: Bytes!   # address
  tokenId: BigInt! # uint256
  pool: Pool!
  fromIndex: Int!  # uint256
  toIndex: Int!    # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# PositionManager ERC-721 transfer event
type Transfer @entity(immutable: true) {
  id: Bytes!
  token: Token!    # token which was transferred
  pool: Pool!
  from: Bytes!     # address
  to: Bytes!       # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PoolCreated @entity(immutable: true) {
  id: Bytes!
  pool: Bytes!        # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

  # # # # # # # # # # # # # # #
  # POSITION MANAGER ENTITIES #
  # # # # # # # # # # # # # # #

type Position @entity {
  id: Bytes! # byte encoded tokenId
  indexes: [Lend!]! # list of lends which constitute a position
  owner: Bytes! # address of the position owner
  pool: Bytes!  # address of the pool that the position is associated with
  token: Token! # pointer to positionNFT
}

  # # # # # # # # # # # # # #
  # POSITION MANAGER EVENTS #
  # # # # # # # # # # # # # #

type Burn @entity(immutable: true) {
  id: Bytes!
  lender: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MemorializePosition @entity(immutable: true) {
  id: Bytes!
  lender: Bytes!   # address
  tokenId: BigInt! # uint256
  indexes: [Int!]! # uint256[]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Mint @entity(immutable: true) {
  id: Bytes!
  lender: Bytes! # address
  pool: Pool!
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RedeemPosition @entity(immutable: true) {
  id: Bytes!
  lender: Bytes!   # address
  tokenId: BigInt! # uint256
  pool: Pool!
  indexes: [Int!]! # uint256[]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

  # # # # # # # # # # # # # #
  # REWARDS MANAGER EVENTS  #
  # # # # # # # # # # # # # #

type ClaimRewards @entity(immutable: true) {
  id: Bytes!
  owner: Bytes!             # address
  pool: Pool!
  tokenId: BigInt!          # uint256
  epochsClaimed: [BigInt!]! # uint256[]
  amount: BigDecimal!       # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MoveStakedLiquidity @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt!     # uint256
  pool: Pool!
  fromIndexes: [Int!]! # uint256
  toIndexes: [Int!]!   # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Stake @entity(immutable: true) {
  id: Bytes!
  owner: Bytes!    # address
  pool: Pool!
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Unstake @entity(immutable: true) {
  id: Bytes!
  owner: Bytes!    # address
  pool: Pool!
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UpdateExchangeRates @entity(immutable: true) {
  id: Bytes!
  caller: Bytes!             # address
  pool: Pool!
  indexesUpdated: [BigInt!]! # uint256[]
  rewardsClaimed: BigInt!    # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

  # # # # # # # # # # # #
  # GRANT FUND ENTITIES #
  # # # # # # # # # # # #

type GrantFund @entity {
  id: Bytes! # address of the grant fund
  treasury: BigDecimal! # Total ajna tokens in the grant fund treasure
  standardProposals: [Proposal!]! # List of standard proposals submitted to the grant fund
  standardProposalsExecuted: [Proposal!]! # List of standard proposals executed by the grant fund
  extraordinaryProposals: [Proposal!]! # List of extraordinary proposals submitted to the grant fund
  extraordinaryProposalsExecuted: [Proposal!]! # List of extraordinary proposals executed by the grant fund
  distributionPeriods: [DistributionPeriod!]! # List of distribution periods
  totalDelegationRewardsClaimed: BigDecimal! # Total delegation rewards claimed across all distribution periods
}

type DistributionPeriod @entity {
  id: Bytes! # distribution period id converted to Bytes from uint
  startBlock: BigInt! # block number the distribution period starts
  endBlock: BigInt! # block number the distribution period ends
  topSlate: FundedSlate! # The current top FundedSlate
  slatesSubmitted: [FundedSlate!]! # FundedSlate[] slates submitted in the distribution period
  delegationRewardsClaimed: BigDecimal! # Total delegation rewards claimed in the distribution period
  fundingVotesCast: BigDecimal! # number of funding votes cast
  fundingVotePowerUsed: BigDecimal! # Total funding vote power used
  screeningVotesCast: BigDecimal! # number of screening votes cast
  proposals: [Proposal!]! # List of proposals submitted in the distribution period
  totalTokensRequested: BigDecimal! # Total ajna tokens requested by all proposals in the distribution period
}

# TODO: split into standard and extraordinary?
type Proposal @entity {
  id: Bytes! # proposal id converted to Bytes from uint
  description: String! # proposal description hashed as part of proposalId
  distribution: DistributionPeriod # distributionPeriod in which the proposal was submitted if Standard, null otherwise
  isStandard: Boolean! # bool
  isExtraordinary: Boolean! # bool
  executed: Boolean! # bool
  successful: Boolean! # bool
  extraordinaryVotesReceived: BigDecimal! # uint256
  screeningVotesReceived: BigDecimal! # uint256
  fundingVotesReceived: BigDecimal! # uint256
  totalTokensRequested: BigDecimal! # uint256
  params: [ProposalParams!]! # ProposalParams
}

type ProposalParams @entity {
  id: Bytes! # $proposalId + '|' + $paramIndex
  target: Bytes! # address
  value: BigInt! # uint256
  calldata: Bytes! # bytes
  recipient: Bytes! # address
  tokensRequested: BigDecimal! # uint256
}

type Voter @entity {
  id: Bytes! # voter address
  proposalsCreated: [Proposal!]! # Proposal[]
  proposalsExecuted: [Proposal!]! # Proposal[]
  distributionPeriodVotes: [DistributionPeriodVote!]! # DistributionPeriodVote[]
  extraordinaryVotes: [ExtraordinaryVote!]! # ExtraordinaryVote[]
}

# TODO: record voting power used?
type DistributionPeriodVote @entity {
  id: Bytes! # $voterId + '|'' + $distributionId
  distribution: DistributionPeriod! # uint256
  screeningStageVotingPower: BigDecimal! # uint256
  fundingStageVotingPower: BigDecimal! # uint256
  screeningVotes: [ScreeningVote!]! # ScreeningVote[]
  fundingVotes: [FundingVote!]! # FundingVote[]
}

type ScreeningVote @entity {
  id: Bytes! # $proposalId + 'screening' + $Voter.id + $logIndex
  distribution: DistributionPeriod! # distribution period the vote was cast in
  voter: Voter! # Voter
  proposal: Proposal! # proposal being voted on
  votesCast: BigDecimal! # uint256
  blockNumber: BigInt! # block number the vote was cast
}

type FundingVote @entity {
  id: Bytes! # $proposalId + 'funding' + $Voter.id + $logIndex
  distribution: DistributionPeriod! # distribution period the vote was cast in
  voter: Voter! # Voter
  proposal: Proposal! # proposal being voted on
  votesCast: BigDecimal! # uint256 # TODO: can this be negative?
  votingPowerUsed: BigDecimal! # uint256
  blockNumber: BigInt! # block number the vote was cast
}

type ExtraordinaryVote @entity {
  id: Bytes! # $proposalId + 'extraordinary' + $Voter.id
  voter: Voter! # Voter
  proposal: Proposal! # proposal being voted on
  voteBlock: BigInt! # block number the vote was cast
  votesCast: BigDecimal! # uint256 amount of votes cast
}

type FundedSlate @entity {
  id: Bytes! # bytes32 hash of slate proposalIds
  distribution: DistributionPeriod! # distribution period the vote was cast in
  proposals: [Proposal!]! # uint256[] list of proposalIds
  updateBlock: BigInt! # block number the slate was updated
}

# TODO: add stage specific entities?
# type ScreeningStage @entity {}

  # # # # # # # # # # #
  # GRANT FUND EVENTS #
  # # # # # # # # # # #

# TODO: should we be able to track the distribution period for which the rewards have accrued?
type DelegateRewardClaimed @entity(immutable: true) {
  id: Bytes!
  delegateeAddress_: Bytes! # address
  distribution: DistributionPeriod! # distribution period the rewards were claimed in
  rewardClaimed_: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type FundTreasury @entity(immutable: true) {
  id: Bytes!
  amount: BigInt! # uint256
  treasuryBalance: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type FundedSlateUpdated @entity(immutable: true) {
  id: Bytes!
  distributionId_: BigInt! # uint256
  fundedSlateHash_: Bytes! # bytes32
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProposalCreated @entity(immutable: true) {
  id: Bytes!
  proposalId: BigInt! # uint256
  proposer: Bytes! # address
  targets: [Bytes!]! # address[]
  values: [BigInt!]! # uint256[]
  signatures: [String!]! # string[]
  calldatas: [Bytes!]! # bytes[]
  startBlock: BigInt! # uint256
  endBlock: BigInt! # uint256
  description: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ProposalExecuted @entity(immutable: true) {
  id: Bytes!
  proposalId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# TODO: remove underscores from event fields
type QuarterlyDistributionStarted @entity(immutable: true) {
  id: Bytes!
  distribution: DistributionPeriod! # The newly started distribution period
  startBlock_: BigInt! # uint256
  endBlock_: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VoteCast @entity(immutable: true) {
  id: Bytes!
  voter: Bytes! # address
  proposalId: BigInt! # uint256
  support: Int! # uint8
  weight: BigInt! # uint256
  reason: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
